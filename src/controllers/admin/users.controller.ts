import { Response, NextFunction } from 'express';
import { AdminRequest } from '../../middleware/admin';
import { User, IUser } from '../../models/User';
import { Earning } from '../../models/Earning';
import { Withdrawal } from '../../models/Withdrawal';
import { createError } from '../../utils/errors';

/**
 * Create User (Admin)
 * POST /api/v1/admin/users
 */
export const createUser = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { name, email, phone, password, role = 'user', kycStatus = 'pending', isEmailVerified = false, isPhoneVerified = false } = req.body;

    // Check if email already exists
    const existingEmail = await User.findOne({ email: email.toLowerCase() });
    if (existingEmail) {
      throw createError('Email already exists', 409, 'DUPLICATE_ENTRY', [{ field: 'email', message: 'Email already exists' }]);
    }

    // Check if phone already exists
    const existingPhone = await User.findOne({ phone });
    if (existingPhone) {
      throw createError('Phone number already exists', 409, 'DUPLICATE_ENTRY', [{ field: 'phone', message: 'Phone number already exists' }]);
    }

    // Create user (password will be hashed by User model's pre-save hook)
    const user = await User.create({
      name,
      email: email.toLowerCase(),
      phone,
      password, // Will be hashed automatically by the model
      role,
      kycStatus,
      isEmailVerified,
      isPhoneVerified,
      walletBalance: 0,
      totalEarnings: 0,
      totalWithdrawals: 0,
      totalReferrals: 0,
      activeReferrals: 0,
      referralEarnings: 0,
      // Referral code will be auto-generated by the model's pre-save hook
    });

    res.status(201).json({
      success: true,
      message: 'User created successfully',
      data: {
        user: {
          id: user._id.toString(),
          name: user.name,
          email: user.email,
          phone: user.phone,
          status: 'active', // All users are active by default (no status field in model yet)
          kycStatus: user.kycStatus || 'pending',
          role: user.role || 'user',
          walletBalance: user.walletBalance || 0,
          totalEarnings: user.totalEarnings || 0,
          totalWithdrawals: user.totalWithdrawals || 0,
          emailVerified: user.isEmailVerified || false,
          phoneVerified: user.isPhoneVerified || false,
          registrationDate: user.createdAt,
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * List Users (Admin)
 * GET /api/v1/admin/users
 */
export const listUsers = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { page = 1, limit = 20, search, role, status, kycStatus, sortBy = 'createdAt', sortOrder = 'desc' } = req.query;
    const skip = (Number(page) - 1) * Number(limit);

    const query: Record<string, unknown> = {};

    // By default exclude admins; include when role=admin is explicitly requested
    if (role) query.role = role;
    else query.role = { $ne: 'admin' };
    if (status) query.status = status;
    if (kycStatus) query.kycStatus = kycStatus;

    if (search && typeof search === 'string') {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
        { phone: { $regex: search, $options: 'i' } },
      ];
    }

    const sort: Record<string, 1 | -1> = {};
    sort[sortBy as string] = sortOrder === 'asc' ? 1 : -1;

    const [users, total] = await Promise.all([
      User.find(query)
        .select('-password -refreshToken -resetPasswordToken -resetPasswordExpires -__v')
        .sort(sort)
        .skip(skip)
        .limit(Number(limit)),
      User.countDocuments(query),
    ]);

    const usersData = users.map((user) => ({
      id: user._id.toString(),
      name: user.name,
      email: user.email,
      phone: user.phone,
      status: user.status || 'active',
      role: user.role || 'user',
      walletBalance: user.walletBalance || 0,
      totalEarnings: user.totalEarnings || 0,
      totalWithdrawals: user.totalWithdrawals || 0,
      kycStatus: user.kycStatus || 'pending',
      emailVerified: user.isEmailVerified || false,
      phoneVerified: user.isPhoneVerified || false,
      registrationDate: user.createdAt,
      profileImage: user.profileImage || null,
    }));

    const totalPages = Math.ceil(total / Number(limit));

    res.json({
      success: true,
      data: {
        users: usersData,
        total,
        page: Number(page),
        limit: Number(limit),
        totalPages,
      },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get Single User (Admin)
 * GET /api/v1/admin/users/:userId
 */
export const getUser = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;

    const user = await User.findById(userId)
      .select('-password -refreshToken -resetPasswordToken -resetPasswordExpires -__v')
      .populate('referredBy', 'name email');

    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    const lastLogin = user.lastLogin || user.updatedAt;

    res.json({
      success: true,
      data: {
        user: {
          id: user._id.toString(),
          name: user.name,
          email: user.email,
          phone: user.phone,
          status: user.status || 'active',
          role: user.role || 'user',
          walletBalance: user.walletBalance || 0,
          totalEarnings: user.totalEarnings || 0,
          totalWithdrawals: user.totalWithdrawals || 0,
          kycStatus: user.kycStatus || 'pending',
          emailVerified: user.isEmailVerified || false,
          phoneVerified: user.isPhoneVerified || false,
          profileImage: user.profileImage || null,
          address: user.address || null,
          referralCode: user.referralCode || null,
          totalReferrals: user.totalReferrals || 0,
          activeReferrals: user.activeReferrals || 0,
          referralEarnings: user.referralEarnings || 0,
          referredBy: user.referredBy ? {
            id: (user.referredBy as any)._id?.toString(),
            name: (user.referredBy as any).name,
            email: (user.referredBy as any).email,
          } : null,
          registrationDate: user.createdAt,
          lastLogin: lastLogin,
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Update User (Admin)
 * PUT /api/v1/admin/users/:userId
 */
export const updateUser = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;
    const { name, phone, address, profileImage, kycStatus, isEmailVerified, isPhoneVerified } = req.body;

    const user = await User.findById(userId);
    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    if (phone && phone !== user.phone) {
      const existingUser = await User.findOne({ phone, _id: { $ne: user._id } });
      if (existingUser) {
        throw createError('Phone number already exists', 409, 'DUPLICATE_ENTRY', [{ field: 'phone', message: 'Phone number already exists' }]);
      }
      user.phone = phone;
    }

    if (name !== undefined) user.name = name;
    if (address !== undefined) user.address = { ...(user.address || {}), ...address } as IUser['address'];
    if (profileImage !== undefined) user.profileImage = profileImage;
    if (kycStatus !== undefined) user.kycStatus = kycStatus;
    if (isEmailVerified !== undefined) user.isEmailVerified = isEmailVerified;
    if (isPhoneVerified !== undefined) user.isPhoneVerified = isPhoneVerified;

    await user.save();

    res.json({
      success: true,
      message: 'User updated successfully',
      data: {
        user: {
          id: user._id.toString(),
          name: user.name,
          email: user.email,
          phone: user.phone,
          kycStatus: user.kycStatus,
          isEmailVerified: user.isEmailVerified,
          isPhoneVerified: user.isPhoneVerified,
          updatedAt: user.updatedAt,
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Adjust User Balance (Admin)
 * POST /api/v1/admin/users/:userId/adjust-balance
 */
export const adjustUserBalance = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;
    const { amount, reason } = req.body;

    const user = await User.findById(userId);
    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    const previousBalance = user.walletBalance || 0;
    const newBalance = previousBalance + amount;

    // Check if balance would go negative
    if (newBalance < 0) {
      throw createError('Insufficient balance. Cannot adjust balance below zero.', 400, 'VALIDATION_ERROR');
    }

    // Update user balance
    user.walletBalance = newBalance;
    
    // If it's a credit, also update totalEarnings (for positive amounts)
    if (amount > 0) {
      user.totalEarnings = (user.totalEarnings || 0) + amount;
    }

    await user.save();

    // Note: To create an Earning record for admin adjustments, we need a valid productId
    // For now, we'll skip creating the earning record as productId is required
    // In production, you may want to:
    // 1. Create a special "System" or "Admin Adjustment" product
    // 2. Or make productId optional for admin adjustments
    // 3. Or use a different transaction model for admin adjustments

    res.json({
      success: true,
      message: 'Balance adjusted successfully',
      data: {
        userId: user._id.toString(),
        previousBalance,
        newBalance,
        adjustment: amount,
        reason,
      },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Freeze/Unfreeze User (Admin)
 * POST /api/v1/admin/users/:userId/freeze
 */
export const freezeUser = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;
    const { freeze, reason } = req.body;

    if (userId === req.admin?.id) {
      throw createError('You cannot freeze your own account', 403, 'FORBIDDEN');
    }

    const user = await User.findById(userId);
    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    (user as any).status = freeze ? 'frozen' : 'active';
    if (freeze && reason) (user as any).freezeReason = reason;
    else (user as any).freezeReason = undefined;
    await user.save();

    res.json({
      success: true,
      message: freeze ? 'User account frozen' : 'User account unfrozen',
      data: {
        userId: user._id.toString(),
        status: (user as any).status,
        reason: freeze ? reason || null : null,
      },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get User Transactions (Admin)
 * GET /api/v1/admin/users/:userId/transactions
 * Combines Earnings (credits) and Withdrawals (debits)
 */
export const getUserTransactions = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;
    const { page = 1, limit = 20, type, status } = req.query;
    const skip = (Number(page) - 1) * Number(limit);

    const user = await User.findById(userId);
    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    // Build queries for earnings (credits) and withdrawals (debits)
    const earningQuery: any = { userId: user._id };
    const withdrawalQuery: any = { userId: user._id };

    if (type === 'credit') {
      // Only get earnings
      const [earnings, earningsTotal] = await Promise.all([
        Earning.find(earningQuery)
          .populate('productId', 'name')
          .sort({ createdAt: -1 })
          .skip(skip)
          .limit(Number(limit)),
        Earning.countDocuments(earningQuery),
      ]);

      const transactions = earnings.map((earning) => ({
        id: earning._id.toString(),
        userId: earning.userId.toString(),
        type: 'credit',
        amount: earning.amount,
        status: earning.status,
        description: `Earning from ${(earning.productId as any)?.name || 'offer'}`,
        relatedApplicationId: earning.applicationId?.toString() || null,
        createdAt: earning.createdAt,
      }));

      const totalPages = Math.ceil(earningsTotal / Number(limit));

      res.json({
        success: true,
        data: {
          transactions,
          pagination: {
            page: Number(page),
            limit: Number(limit),
            total: earningsTotal,
            totalPages,
          },
        },
      });
    }

    if (type === 'debit') {
      // Only get withdrawals
      if (status) {
        withdrawalQuery.status = status;
      }

      const [withdrawals, withdrawalsTotal] = await Promise.all([
        Withdrawal.find(withdrawalQuery)
          .sort({ createdAt: -1 })
          .skip(skip)
          .limit(Number(limit)),
        Withdrawal.countDocuments(withdrawalQuery),
      ]);

      const transactions = withdrawals.map((withdrawal) => ({
        id: withdrawal._id.toString(),
        userId: withdrawal.userId.toString(),
        type: 'debit',
        amount: withdrawal.amount,
        status: withdrawal.status,
        description: `Withdrawal request`,
        relatedApplicationId: null,
        createdAt: withdrawal.createdAt,
      }));

      const totalPages = Math.ceil(withdrawalsTotal / Number(limit));

      res.json({
        success: true,
        data: {
          transactions,
          pagination: {
            page: Number(page),
            limit: Number(limit),
            total: withdrawalsTotal,
            totalPages,
          },
        },
      });
    }

    // Get both earnings and withdrawals, combine and sort
    const [earnings, withdrawals] = await Promise.all([
      Earning.find(earningQuery).sort({ createdAt: -1 }).limit(Number(limit) * 2),
      Withdrawal.find(withdrawalQuery).sort({ createdAt: -1 }).limit(Number(limit) * 2),
    ]);

    // Combine and sort by date
    const allTransactions = [
      ...earnings.map((earning) => ({
        id: earning._id.toString(),
        userId: earning.userId.toString(),
        type: 'credit' as const,
        amount: earning.amount,
        status: earning.status,
        description: `Earning from offer`,
        relatedApplicationId: earning.applicationId?.toString() || null,
        createdAt: earning.createdAt,
      })),
      ...withdrawals.map((withdrawal) => ({
        id: withdrawal._id.toString(),
        userId: withdrawal.userId.toString(),
        type: 'debit' as const,
        amount: withdrawal.amount,
        status: withdrawal.status,
        description: `Withdrawal request`,
        relatedApplicationId: null,
        createdAt: withdrawal.createdAt,
      })),
    ].sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

    // Apply status filter if provided
    let filteredTransactions = allTransactions;
    if (status) {
      filteredTransactions = allTransactions.filter((t) => t.status === status);
    }

    // Apply pagination
    const paginatedTransactions = filteredTransactions.slice(skip, skip + Number(limit));
    const total = filteredTransactions.length;
    const totalPages = Math.ceil(total / Number(limit));

    res.json({
      success: true,
      data: {
        transactions: paginatedTransactions,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total,
          totalPages,
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Delete User (Admin) - soft delete (inactive) or hard delete
 * DELETE /api/v1/admin/users/:userId
 */
export const deleteUser = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;
    const body = req.body || {};
    const hard = body.hard === true;

    if (userId === req.admin?.id) {
      throw createError('You cannot delete your own account', 403, 'FORBIDDEN');
    }

    const user = await User.findById(userId);
    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    if (user.role === 'admin') {
      const adminCount = await User.countDocuments({ role: 'admin' });
      if (adminCount <= 1) {
        throw createError('Cannot delete the last admin', 403, 'FORBIDDEN');
      }
    }

    if (hard) {
      await User.findByIdAndDelete(userId);
      res.json({
        success: true,
        message: 'User permanently deleted',
        data: { userId },
      });
    } else {
      user.status = 'inactive';
      await user.save();
      res.json({
        success: true,
        message: 'User deactivated successfully',
        data: { userId, status: 'inactive' },
      });
    }
  } catch (error) {
    next(error);
  }
};

/**
 * Change User Role (Admin)
 * PUT /api/v1/admin/users/:userId/role
 */
export const changeRole = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;
    const { role } = req.body;

    const user = await User.findById(userId);
    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    if (userId === req.admin?.id && role !== 'admin') {
      const adminCount = await User.countDocuments({ role: 'admin' });
      if (adminCount <= 1) {
        throw createError('Cannot remove admin role from the last admin', 403, 'FORBIDDEN');
      }
    }

    user.role = role;
    await user.save();

    res.json({
      success: true,
      message: 'User role updated successfully',
      data: { userId: user._id.toString(), role: user.role },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Verify User Email (Admin override)
 * PUT /api/v1/admin/users/:userId/verify-email
 */
export const verifyEmail = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;
    const verified = req.body?.verified !== false;

    const user = await User.findById(userId);
    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    user.isEmailVerified = verified;
    await user.save();

    res.json({
      success: true,
      message: verified ? 'Email marked as verified' : 'Email verification removed',
      data: { userId: user._id.toString(), isEmailVerified: user.isEmailVerified },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Verify User Phone (Admin override)
 * PUT /api/v1/admin/users/:userId/verify-phone
 */
export const verifyPhone = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;
    const verified = req.body?.verified !== false;

    const user = await User.findById(userId);
    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    user.isPhoneVerified = verified;
    await user.save();

    res.json({
      success: true,
      message: verified ? 'Phone marked as verified' : 'Phone verification removed',
      data: { userId: user._id.toString(), isPhoneVerified: user.isPhoneVerified },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Update User KYC Status (Admin)
 * PUT /api/v1/admin/users/:userId/kyc-status
 */
export const updateKycStatus = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;
    const { kycStatus } = req.body;

    const user = await User.findById(userId);
    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    user.kycStatus = kycStatus;
    await user.save();

    res.json({
      success: true,
      message: 'KYC status updated successfully',
      data: { userId: user._id.toString(), kycStatus: user.kycStatus },
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get User Statistics (Admin)
 * GET /api/v1/admin/users/:userId/statistics
 */
export const getUserStatistics = async (req: AdminRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { userId } = req.params;

    const user = await User.findById(userId)
      .select('name email walletBalance totalEarnings totalWithdrawals totalReferrals activeReferrals referralEarnings createdAt')
      .lean();
    if (!user) {
      throw createError('User not found', 404, 'NOT_FOUND');
    }

    const [earningsCount, earningsSum, withdrawalsCount, withdrawalsSum] = await Promise.all([
      Earning.countDocuments({ userId: user._id }),
      Earning.aggregate([{ $match: { userId: user._id } }, { $group: { _id: null, total: { $sum: '$amount' } } }]),
      Withdrawal.countDocuments({ userId: user._id }),
      Withdrawal.aggregate([{ $match: { userId: user._id } }, { $group: { _id: null, total: { $sum: '$amount' } } }]),
    ]);

    const totalEarned = earningsSum[0]?.total ?? 0;
    const totalWithdrawn = withdrawalsSum[0]?.total ?? 0;

    res.json({
      success: true,
      data: {
        user: {
          id: user._id.toString(),
          name: user.name,
          email: user.email,
          createdAt: user.createdAt,
        },
        wallet: {
          balance: user.walletBalance ?? 0,
          totalEarnings: user.totalEarnings ?? 0,
          totalWithdrawals: user.totalWithdrawals ?? 0,
        },
        referral: {
          totalReferrals: user.totalReferrals ?? 0,
          activeReferrals: user.activeReferrals ?? 0,
          referralEarnings: user.referralEarnings ?? 0,
        },
        transactions: {
          earningsCount,
          totalEarned,
          withdrawalsCount,
          totalWithdrawn,
        },
      },
    });
  } catch (error) {
    next(error);
  }
};

